name: Cloudflare IP Test & Collection

on:
  schedule:
    # 每天运行2次：0点、12点
    - cron: '0 0,12 * * *'
  workflow_dispatch:
    inputs:
      ip_source:
        description: 'IP数据源'
        required: true
        default: 'official'
        type: choice
        options:
          - official
          - as13335
          - as209242
          - as24429
          - as35916
          - as199524
          - cm
          - proxyip
      target_port:
        description: '目标端口'
        required: false
        default: '443'
        type: string
      max_ips:
        description: '最大IP数量'
        required: false
        default: '512'
        type: string
      enable_save:
        description: '保存结果到仓库'
        required: false
        default: true
        type: boolean

env:
  MAX_IPS: ${{ github.event.inputs.max_ips || '512' }}
  TARGET_PORT: ${{ github.event.inputs.target_port || '443' }}
  IP_SOURCE: ${{ github.event.inputs.ip_source || 'official' }}

jobs:
  collect-ips:
    runs-on: ubuntu-latest
    name: Collect Cloudflare IPs
    outputs:
      ip_count: ${{ steps.collect_ips.outputs.ip_count }}
      ip_source: ${{ steps.collect_ips.outputs.ip_source }}
      timestamp: ${{ steps.collect_ips.outputs.timestamp }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: |
          npm install axios
          npm install ip-cidr
          
      - name: Collect Cloudflare IPs
        id: collect_ips
        run: |
          node -e '
          const axios = require("axios");
          
          const MAX_IPS = parseInt(process.env.MAX_IPS);
          const TARGET_PORT = process.env.TARGET_PORT;
          const IP_SOURCE = process.env.IP_SOURCE;
          
          console.log("开始收集Cloudflare IP...");
          console.log("数据源:", IP_SOURCE);
          console.log("目标端口:", TARGET_PORT);
          console.log("最大IP数量:", MAX_IPS);
          
          function isValidIP(ip) {
            const ipRegex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
            const match = ip.match(ipRegex);
            if (!match) return false;
            
            for (let i = 1; i <= 4; i++) {
              const num = parseInt(match[i]);
              if (num < 0 || num > 255) return false;
            }
            return true;
          }
          
          function parseProxyIPLine(line, targetPort) {
            try {
              line = line.trim();
              if (!line) return null;
              
              let ip = "";
              let port = "";
              let comment = "";
              
              if (line.includes("#")) {
                const parts = line.split("#");
                const mainPart = parts[0].trim();
                comment = parts[1].trim();
                
                if (mainPart.includes(":")) {
                  const ipPortParts = mainPart.split(":");
                  if (ipPortParts.length === 2) {
                    ip = ipPortParts[0].trim();
                    port = ipPortParts[1].trim();
                  } else {
                    return null;
                  }
                } else {
                  ip = mainPart;
                  port = "443";
                }
              } else {
                if (line.includes(":")) {
                  const ipPortParts = line.split(":");
                  if (ipPortParts.length === 2) {
                    ip = ipPortParts[0].trim();
                    port = ipPortParts[1].trim();
                  } else {
                    return null;
                  }
                } else {
                  ip = line;
                  port = "443";
                }
              }
              
              if (!isValidIP(ip)) return null;
              
              const portNum = parseInt(port);
              if (isNaN(portNum) || portNum < 1 || portNum > 65535) return null;
              
              if (port !== targetPort) return null;
              
              if (comment) {
                return ip + ":" + port + "#" + comment;
              } else {
                return ip + ":" + port;
              }
            } catch (error) {
              return null;
            }
          }
          
          function generateIPsFromCIDR(cidr, count = 1) {
            try {
              const [network, prefix] = cidr.split("/");
              const prefixNum = parseInt(prefix);
              
              if (prefixNum < 0 || prefixNum > 32) return [];
              
              const ipToNum = (ip) => {
                return ip.split(".").reduce((acc, octet, index) => {
                  return acc + (parseInt(octet) << (8 * (3 - index)));
                }, 0);
              };
              
              const numToIp = (num) => {
                return [
                  (num >>> 24) & 255,
                  (num >>> 16) & 255,
                  (num >>> 8) & 255,
                  num & 255
                ].join(".");
              };
              
              const networkNum = ipToNum(network);
              const hostBits = 32 - prefixNum;
              const maxHosts = Math.pow(2, hostBits) - 2;
              
              if (maxHosts <= 0) return [];
              
              const actualCount = Math.min(count, maxHosts);
              const ips = new Set();
              
              const startHost = networkNum + 1;
              const endHost = networkNum + maxHosts;
              
              const availableIPs = [];
              for (let i = startHost; i <= endHost; i++) {
                availableIPs.push(numToIp(i));
              }
              
              while (ips.size < actualCount && availableIPs.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableIPs.length);
                ips.add(availableIPs[randomIndex]);
                availableIPs.splice(randomIndex, 1);
              }
              
              return Array.from(ips);
            } catch (error) {
              return [];
            }
          }
          
          async function getCFIPs(ipSource, targetPort) {
            try {
              let response;
              let text = "";
              
              const sources = {
                "official": "https://www.cloudflare.com/ips-v4/",
                "as13335": "https://raw.githubusercontent.com/ipverse/asn-ip/master/as/13335/ipv4-aggregated.txt",
                "as209242": "https://raw.githubusercontent.com/ipverse/asn-ip/master/as/209242/ipv4-aggregated.txt",
                "as24429": "https://raw.githubusercontent.com/ipverse/asn-ip/master/as/24429/ipv4-aggregated.txt",
                "as35916": "https://raw.githubusercontent.com/ipverse/asn-ip/master/as/35916/ipv4-aggregated.txt",
                "as199524": "https://raw.githubusercontent.com/ipverse/asn-ip/master/as/199524/ipv4-aggregated.txt",
                "cm": "https://raw.githubusercontent.com/cmliu/cmliu/main/CF-CIDR.txt",
                "proxyip": "https://raw.githubusercontent.com/cmliu/ACL4SSR/main/baipiao.txt"
              };
              
              if (ipSource === "proxyip") {
                response = await axios.get(sources[ipSource]);
                if (response.status === 200) {
                  const lines = response.data.split("\n")
                    .map(line => line.trim())
                    .filter(line => line && !line.startsWith("#"));
                  
                  const validIps = [];
                  for (const line of lines) {
                    const parsed = parseProxyIPLine(line, targetPort);
                    if (parsed) validIps.push(parsed);
                  }
                  
                  console.log("反代IP解析完成，端口" + targetPort + "匹配到" + validIps.length + "个有效IP");
                  
                  if (validIps.length > MAX_IPS) {
                    const shuffled = [...validIps].sort(() => 0.5 - Math.random());
                    return shuffled.slice(0, MAX_IPS);
                  }
                  return validIps;
                }
              } else {
                response = await axios.get(sources[ipSource] || sources["official"]);
                text = response.status === 200 ? response.data : "173.245.48.0/20\n103.21.244.0/22\n103.22.200.0/22\n103.31.4.0/22\n141.101.64.0/18\n108.162.192.0/18\n190.93.240.0/20\n188.114.96.0/20\n197.234.240.0/22\n198.41.128.0/17\n162.158.0.0/15\n104.16.0.0/13\n104.24.0.0/14\n172.64.0.0/13\n131.0.72.0/22";
              }
              
              const cidrs = text.split("\n").filter(line => line.trim() && !line.startsWith("#"));
              const ips = new Set();
              let round = 1;
              
              while (ips.size < MAX_IPS) {
                console.log("第" + round + "轮生成IP，当前已有" + ips.size + "个");
                
                for (const cidr of cidrs) {
                  if (ips.size >= MAX_IPS) break;
                  
                  const cidrIPs = generateIPsFromCIDR(cidr.trim(), round);
                  cidrIPs.forEach(ip => ips.add(ip));
                }
                
                round++;
                if (round > 100) {
                  console.warn("达到最大轮次限制，停止生成");
                  break;
                }
              }
              
              console.log("最终生成" + ips.size + "个不重复IP");
              return Array.from(ips).slice(0, MAX_IPS);
            } catch (error) {
              console.error("获取CF IPs失败:" + error.message);
              return [];
            }
          }
          
          (async () => {
            try {
              const ips = await getCFIPs(IP_SOURCE, TARGET_PORT);
              
              const fs = require("fs");
              const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
              const filename = "cf-ips-" + IP_SOURCE + "-" + timestamp + ".txt";
              
              fs.writeFileSync(filename, ips.join("\n"));
              console.log("已保存" + ips.length + "个IP到 " + filename);
              
              const output = "ip_count=" + ips.length + "\nip_source=" + IP_SOURCE + "\nfilename=" + filename + "\ntimestamp=" + timestamp + "\n";
              fs.appendFileSync(process.env.GITHUB_OUTPUT, output);
              
              fs.writeFileSync("latest-cf-ips.txt", ips.join("\n"));
              
              process.exit(0);
            } catch (error) {
              console.error("执行失败:", error);
              process.exit(1);
            }
          })();
          '
          
      - name: Upload IP list as artifact
        uses: actions/upload-artifact@v4
        with:
          name: cf-ips-${{ env.IP_SOURCE }}-${{ steps.collect_ips.outputs.timestamp }}
          path: |
            ${{ steps.collect_ips.outputs.filename }}
            latest-cf-ips.txt
          retention-days: 30
          
      - name: Commit IP list to repository
        if: github.event.inputs.enable_save != 'false' && steps.collect_ips.outputs.ip_count > 0
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          mkdir -p ips/${{ env.IP_SOURCE }}
          cp latest-cf-ips.txt ips/${{ env.IP_SOURCE }}/latest.txt
          cp ${{ steps.collect_ips.outputs.filename }} ips/${{ env.IP_SOURCE }}/
          
          cat > ips/README.md << 'EOF'
          # Cloudflare IP Collection
          
          ## Latest Statistics
          - **Source**: ${{ env.IP_SOURCE }}
          - **Count**: ${{ steps.collect_ips.outputs.ip_count }} IPs
          - **Port**: ${{ env.TARGET_PORT }}
          - **Updated**: $(date -u)
          
          ## Available Sources
          EOF
          
          ls -1 ips/ | grep -v README.md | while read dir; do
            count=$(wc -l < ips/$dir/latest.txt 2>/dev/null || echo "0")
            echo "- **$dir**: $count IPs" >> ips/README.md
          done
          
          git add ips/
          git commit -m "Update ${{ env.IP_SOURCE }} IPs - ${{ steps.collect_ips.outputs.ip_count }} IPs collected" || exit 0
          
      - name: Push changes
        if: github.event.inputs.enable_save != 'false' && steps.collect_ips.outputs.ip_count > 0
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}
          
      - name: Create release
        if: github.event.inputs.enable_save != 'false' && github.event_name == 'workflow_dispatch' && steps.collect_ips.outputs.ip_count > 0
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.IP_SOURCE }}-${{ steps.collect_ips.outputs.timestamp }}
          name: ${{ env.IP_SOURCE }} IPs - ${{ steps.collect_ips.outputs.ip_count }} collected
          body: |
            ## IP Collection Report
            
            - **Source**: ${{ env.IP_SOURCE }}
            - **Target Port**: ${{ env.TARGET_PORT }}
            - **Collected IPs**: ${{ steps.collect_ips.outputs.ip_count }}
            - **Collection Time**: ${{ steps.collect_ips.outputs.timestamp }}
            
            ### Files
            - `latest-cf-ips.txt` - Latest IP list
            - `${{ steps.collect_ips.outputs.filename }}` - Timestamped backup
            
            ### Usage
            Download the IP lists from the artifacts or check the `ips/${{ env.IP_SOURCE }}/` directory.
          files: |
            latest-cf-ips.txt
            ${{ steps.collect_ips.outputs.filename }}
          draft: false
          prerelease: false

  test-ips:
    runs-on: ubuntu-latest
    name: Test Collected IPs
    needs: collect-ips
    if: always()
    outputs:
      test_report: ${{ steps.test_ips.outputs.test_report }}
      total_tested: ${{ steps.test_ips.outputs.total_tested }}
      ping_success: ${{ steps.test_ips.outputs.ping_success }}
      port_success: ${{ steps.test_ips.outputs.port_success }}
      ping_rate: ${{ steps.test_ips.outputs.ping_rate }}
      port_rate: ${{ steps.test_ips.outputs.port_rate }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download latest IP list
        uses: actions/download-artifact@v4
        with:
          name: cf-ips-${{ needs.collect-ips.outputs.ip_source }}-${{ needs.collect-ips.outputs.timestamp }}
          path: ./
          
      - name: Test IP connectivity
        id: test_ips
        run: |
          if [ -f "latest-cf-ips.txt" ]; then
            echo "Testing connectivity for collected IPs..."

            sudo apt-get update
            sudo apt-get install -y nmap curl netcat-openbsd bc

            # 创建测试报告
            cat > test-report.md << 'EOF'
# IP Connectivity Test Report
**Generated at**: $(date -u)
**Test Configuration**: ${{ env.TARGET_PORT }}

## Test Results

| IP Address | Clean IP | Port | Ping Status | Port Status | Response Time | Notes |
|------------|----------|------|-------------|-------------|---------------|--------|
EOF

            # 使用临时文件存储统计
            echo "0" > /tmp/total_tested
            echo "0" > /tmp/ping_success
            echo "0" > /tmp/port_success

            # 创建测试IP文件
            head -20 latest-cf-ips.txt > test-ips.txt

            # 测试IP，使用更智能的测试
            while IFS= read -r line; do
              [ -z "$line" ] && continue

              # 清理IP地址
              clean_ip=$(echo "$line" | sed 's/:.*//g' | sed 's/#.*//g' | xargs)

              # 端口测试
              if [[ "$line" == *":"* ]]; then
                port=$(echo "$line" | cut -d':' -f2 | cut -d'#' -f1 | xargs)
              else
                port="443"
              fi

              echo "Testing: $line → $clean_ip:$port"

              # 智能ping测试（跳过ICMP被阻止的情况）
              ping_status="⏭️"
              ping_time=""

              # 先尝试快速ping
              if timeout 3 ping -c 1 -W 2 "$clean_ip" > /dev/null 2>&1; then
                ping_time="$(timeout 3 ping -c 1 -W 2 "$clean_ip" 2>/dev/null | grep 'time=' | sed 's/.*time=\([0-9.]*\).*/\1/')"
                ping_status="✅"
                echo $(( $(cat /tmp/ping_success) + 1 )) > /tmp/ping_success
              else
                # ICMP可能被阻止，标记为跳过
                ping_status="⏭️ (ICMP blocked)"
              fi

              # 增强端口测试（多种方法）
              port_status="❌"
              port_time=""

              # 方法1: 直接TCP连接
              if timeout 4 bash -c "echo >/dev/tcp/$clean_ip/$port" 2>/dev/null; then
                port_status="✅"
                port_time="<1s"
                echo $(( $(cat /tmp/port_success) + 1 )) > /tmp/port_success
              else
                # 方法2: curl HTTPS测试
                if curl -s -o /dev/null -w "%{time_total}" --max-time 6 --connect-timeout 4 "https://$clean_ip:$port" --resolve "$clean_ip:$port:$clean_ip" 2>/dev/null; then
                  port_status="✅ (HTTPS)"
                  port_time="$(curl -s -o /dev/null -w "%{time_total}" --max-time 6 --connect-timeout 4 "https://$clean_ip:$port" --resolve "$clean_ip:$port:$clean_ip" 2>/dev/null)"
                  echo $(( $(cat /tmp/port_success) + 1 )) > /tmp/port_success
                else
                  # 方法3: 基本TCP测试
                  if nc -z -w 3 "$clean_ip" "$port" 2>/dev/null; then
                    port_status="✅ (TCP)"
                    port_time="<1s"
                    echo $(( $(cat /tmp/port_success) + 1 )) > /tmp/port_success
                  else
                    # 方法4: 检查是否开放但无响应
                    if nmap -p "$port" --host-timeout 3s "$clean_ip" 2>/dev/null | grep -q "open"; then
                      port_status="⚠️ (Open but no response)"
                      port_time="N/A"
                    fi
                  fi
                fi
              fi

              # 更新总计
              echo $(( $(cat /tmp/total_tested) + 1 )) > /tmp/total_tested

              # 添加到报告
              echo "| $line | $clean_ip | $port | $ping_status | $port_status | ${ping_time:-${port_time:-N/A}} | - |" >> test-report.md

              # 保存成功的IP
              if [[ "$port_status" == *"✅"* ]]; then
                echo "$clean_ip:$port" >> successful-ips.txt
              fi

            done < test-ips.txt

            # 读取统计结果
            total_tested=$(cat /tmp/total_tested)
            ping_success=$(cat /tmp/ping_success)
            port_success=$(cat /tmp/port_success)

            # 计算成功率
            if [ $total_tested -gt 0 ]; then
              ping_rate=$(awk "BEGIN {printf \"%.1f\", $ping_success * 100 / $total_tested}")
              port_rate=$(awk "BEGIN {printf \"%.1f\", $port_success * 100 / $total_tested}")
              overall_rate=$(awk "BEGIN {printf \"%.1f\", $port_success * 100 / $total_tested}")
            else
              ping_rate="0.0"
              port_rate="0.0"
              overall_rate="0.0"
            fi

            # 生成详细汇总
            cat >> test-report.md << 'EOF'

## Test Summary
- **Total IPs Tested**: $total_tested
- **Ping Success**: $ping_success ($ping_rate%)
- **Port Success**: $port_success ($port_rate%)
- **Overall Usable**: $overall_rate%

## Network Analysis
EOF

            if [ $ping_success -lt 5 ]; then
              echo "- ⚠️ Many IPs blocking ICMP ping (normal for Cloudflare)" >> test-report.md
            fi
            if [ $port_success -gt 10 ]; then
              echo "- ✅ Good port connectivity found" >> test-report.md
            fi
            if [ $port_success -lt 5 ]; then
              echo "- ⚠️ Low port connectivity, consider different target port" >> test-report.md
            fi

            cat >> test-report.md << 'EOF'

## Working IPs for Production
EOF

            # 提取成功的IP
            if [ -f "successful-ips.txt" ] && [ $(cat successful-ips.txt | wc -l) -gt 0 ]; then
              echo "### Successfully Connected IPs:" >> test-report.md
              head -10 successful-ips.txt >> test-report.md
              
              echo "working_ips=$(cat successful-ips.txt | wc -l)" >> $GITHUB_OUTPUT
              
              # 保存成功IP列表
              cp successful-ips.txt working-ips.txt
            else
              echo "- No successful connections found" >> test-report.md
              echo "working_ips=0" >> $GITHUB_OUTPUT
            fi
            
            cat >> test-report.md << 'EOF'

## Usage Recommendations
- Focus on port-successful IPs for actual deployment
- Ping failures are normal for CDN edge IPs
- Test with your specific application requirements
- Consider geographic distribution for optimal performance

## Next Steps
1. Save successful IPs to your application configuration
2. Monitor performance over time
3. Re-run tests periodically for updated results
EOF

            # 设置输出变量
            echo "test_report=test-report.md" >> $GITHUB_OUTPUT
            echo "total_tested=$total_tested" >> $GITHUB_OUTPUT
            echo "ping_success=$ping_success" >> $GITHUB_OUTPUT
            echo "port_success=$port_success" >> $GITHUB_OUTPUT
            echo "ping_rate=$ping_rate" >> $GITHUB_OUTPUT
            echo "port_rate=$port_rate" >> $GITHUB_OUTPUT
            echo "overall_rate=$overall_rate" >> $GITHUB_OUTPUT

            echo "✅ Enhanced connectivity test completed!"
            echo "=== TEST RESULTS ==="
            cat test-report.md

          else
            echo "No IP list found, skipping tests"
            echo "test_report=none" >> $GITHUB_OUTPUT
            echo "total_tested=0" >> $GITHUB_OUTPUT
            echo "working_ips=0" >> $GITHUB_OUTPUT
          fi

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ip-test-results-${{ github.run_number }}
          path: |
            test-report.md
            working-ips.txt
            successful-ips.txt
            test-ips.txt
          retention-days: 30

      - name: Upload successful IPs
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: working-ips-${{ github.run_number }}
          path: working-ips.txt
          retention-days: 7

  summary:
    runs-on: ubuntu-latest
    name: Generate Summary
    needs: [collect-ips, test-ips]
    if: always()
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Generate summary
        run: |
          cat > summary.md << 'EOF'
          # Cloudflare IP Collection Summary
          
          ## Collection Results
          - **Workflow**: ${{ github.workflow }}
          - **Run**: ${{ github.run_number }}
          - **Trigger**: ${{ github.event_name }}
          - **Branch**: ${{ github.ref_name }}
          EOF
          
          if [ "${{ needs.collect-ips.result }}" = "success" ]; then
            echo "- **Collected IPs**: ${{ needs.collect-ips.outputs.ip_count }}" >> summary.md
            echo "- **IP Source**: ${{ needs.collect-ips.outputs.ip_source }}" >> summary.md
            echo "- **Collection Status**: ✅ Success" >> summary.md
          else
            echo "- **Collection Status**: ❌ Failed" >> summary.md
          fi
          
          if [ "${{ needs.test-ips.result }}" = "success" ]; then
            echo "- **Test Status**: ✅ Completed" >> summary.md
          else
            echo "- **Test Status**: ⚠️ Skipped or Failed" >> summary.md
          fi
          
          cat >> summary.md << 'EOF'
          
          ## Available IP Lists
          EOF
          
          if [ -d "ips" ]; then
            ls -1 ips/ | grep -v README.md | while read dir; do
              count=$(wc -l < ips/$dir/latest.txt 2>/dev/null || echo "0")
              echo "- **$dir**: $count IPs" >> summary.md
            done
          else
            echo "- No IP lists found" >> summary.md
          fi
          
          cat >> summary.md << 'EOF'
          
          ## Next Steps
          1. Check the [Artifacts](../actions/runs/${{ github.run_id }}) for detailed IP lists
          2. Review the [Repository](../tree/${{ github.ref_name }}/ips) for historical data
          3. Re-run the workflow with different parameters if needed
          EOF
          
      - name: Upload summary
        uses: actions/upload-artifact@v4
        with:
          name: collection-summary
          path: summary.md
          retention-days: 30
