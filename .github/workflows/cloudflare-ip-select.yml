# Cloudflare IP 优选 GitHub Actions 工作流
# 完全使用Bash脚本实现，无需JavaScript依赖
name: Cloudflare IP 优选

# 触发条件
on:
  # 手动触发
  workflow_dispatch:
    inputs:
      port:
        description: '测试端口'
        required: false
        default: '443'
      count:
        description: '保存的IP数量'
        required: false
        default: '16'
      concurrency:
        description: '并发数'
        required: false
        default: '32'
      timeout:
        description: '超时时间(ms)'
        required: false
        default: '5000'
  
  # 定时触发 (每天凌晨2点)
  schedule:
    - cron: '0 2 * * *'

# 工作流权限
permissions:
  contents: write  # 用于保存结果文件
  actions: read    # 用于读取工作流信息

# 工作流作业
jobs:
  select-cloudflare-ips:
    # 运行环境
    runs-on: ubuntu-latest
    
    # 输出结果
    outputs:
      best_ips: ${{ steps.select-ips.outputs.best_ips }}
      best_ip: ${{ steps.select-ips.outputs.best_ip }}
      ip_count: ${{ steps.select-ips.outputs.ip_count }}
    
    steps:
      # 1. 检出代码（如果需要访问仓库中的其他文件）
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      # 2. 安装必要工具
      - name: 安装必要工具
        run: |
          sudo apt-get update
          sudo apt-get install -y jq parallel curl bc
      
      # 3. 创建并执行IP优选Bash脚本
      - name: 执行IP优选 (使用Bash实现)
        id: select-ips
        run: |
          # 配置参数
          PORT="${{ github.event.inputs.port || '443' }}"
          COUNT="${{ github.event.inputs.count || '16' }}"
          CONCURRENCY="${{ github.event.inputs.concurrency || '32' }}"
          TIMEOUT="${{ github.event.inputs.timeout || '5000' }}"
          OUTPUT_FILE="best-ips.txt"
          NIP_DOMAIN="nip.090227.xyz"
          
          echo "Cloudflare IP优选工具启动"
          echo "配置参数: 端口=${PORT}, 选择数量=${COUNT}, 并发数=${CONCURRENCY}, 超时=${TIMEOUT}ms"
          
          # 步骤1: 获取CM整理的IP列表
          echo "开始加载CM整理的IP列表 (端口: ${PORT})"
          CF_CIDR_LIST=$(curl -sS --max-time 10 "https://raw.githubusercontent.com/cmliu/cmliu/main/CF-CIDR.txt" || echo "173.245.48.0/20\n103.21.244.0/22\n103.22.200.0/22\n103.31.4.0/22\n141.101.64.0/18\n108.162.192.0/18\n190.93.240.0/20\n188.114.96.0/20\n197.234.240.0/22\n198.41.128.0/17\n162.158.0.0/15\n104.16.0.0/13\n104.24.0.0/14\n172.64.0.0/13\n131.0.72.0/22")
          
          # 过滤有效CIDR
          CIDRS=($(echo "${CF_CIDR_LIST}" | grep -v '^#' | grep -v '^$' | tr -d '[:space:]'))
          
          # 步骤2: 从CIDR生成随机IP
          echo "从${#CIDRS[@]}个CIDR生成随机IP..."
          
          # CIDR转随机IP的函数
          generate_random_ip_from_cidr() {
            local cidr="$1"
            local network_part=$(echo $cidr | cut -d'/' -f1)
            local prefix=$(echo $cidr | cut -d'/' -f2)
            
            # 确保prefix是有效的数字
            if ! [[ "$prefix" =~ ^[0-9]+$ ]] || [ "$prefix" -lt 8 ] || [ "$prefix" -gt 30 ]; then
              echo ""  # 返回空值表示无效的prefix
              return
            fi
            
            # 使用bc工具进行大整数运算，避免Bash算术运算的限制
            # 计算子网掩码
            local mask=$(bc <<< "ibase=16; FFFFFFFF << (32 - $prefix); obase=16")
            
            # 将IP转换为整数
            IFS='.' read -r -a ip_parts <<< "$network_part"
            # 确保IP的每个部分都是有效的数字
            if ! [[ "${ip_parts[0]}" =~ ^[0-9]+$ ]] || ! [[ "${ip_parts[1]}" =~ ^[0-9]+$ ]] || \
               ! [[ "${ip_parts[2]}" =~ ^[0-9]+$ ]] || ! [[ "${ip_parts[3]}" =~ ^[0-9]+$ ]]; then
              echo ""  # 返回空值表示无效的IP
              return
            fi
            
            # 使用bc计算IP整数表示
            local ip_int=$(bc <<< "ibase=10; ${ip_parts[0]}*16777216 + ${ip_parts[1]}*65536 + ${ip_parts[2]}*256 + ${ip_parts[3]}; obase=16")
            
            # 计算网络地址 (使用bc进行位运算)
            local network_int=$(bc <<< "ibase=16; $ip_int & $mask; obase=16")
            
            # 计算可用IP范围
            local host_range=$(bc <<< "ibase=16; FFFFFFFF ^ $mask; obase=16")
            # 转换为十进制进行比较和计算
            local network_int_dec=$(bc <<< "ibase=16; $network_int")
            local host_range_dec=$(bc <<< "ibase=16; $host_range")
            local min_ip_dec=$((network_int_dec + 1))  # 排除网络地址
            local max_ip_dec=$((network_int_dec + host_range_dec - 1))  # 排除广播地址
            
            # 如果没有可用IP，返回空
            if [ $min_ip -gt $max_ip ]; then
              return
            fi
            
            # 确保有可用IP
            if [ $min_ip_dec -gt $max_ip_dec ]; then
              echo ""  # 返回空值表示没有可用IP
              return
            fi
            
            # 生成随机IP偏移量
            local random_offset=$((RANDOM % (max_ip_dec - min_ip_dec + 1)))
            local random_ip_dec=$((min_ip_dec + random_offset))
            
            # 将十进制IP转换回点分十进制格式
            # 计算各个八位组的值
            local octet1=$((random_ip_dec / 16777216))
            local remaining1=$((random_ip_dec % 16777216))
            local octet2=$((remaining1 / 65536))
            local remaining2=$((remaining1 % 65536))
            local octet3=$((remaining2 / 256))
            local octet4=$((remaining2 % 256))
            
            # 验证每个八位组在有效范围内
            if [ $octet1 -lt 0 ] || [ $octet1 -gt 255 ] || \
               [ $octet2 -lt 0 ] || [ $octet2 -gt 255 ] || \
               [ $octet3 -lt 0 ] || [ $octet3 -gt 255 ] || \
               [ $octet4 -lt 0 ] || [ $octet4 -gt 255 ]; then
              echo ""  # 返回空值表示无效的IP
              return
            fi
            
            echo "$octet1.$octet2.$octet3.$octet4"
          }
          
          # 生成IP列表
          IPS=()
          TARGET_COUNT=512
          ROUND=1
          
          while [ ${#IPS[@]} -lt $TARGET_COUNT ] && [ $ROUND -le 100 ]; do
            echo "第${ROUND}轮生成IP，当前已有${#IPS[@]}个"
            
            for cidr in "${CIDRS[@]}"; do
              if [ ${#IPS[@]} -ge $TARGET_COUNT ]; then
                break
              fi
              
              # 每轮为每个CIDR生成一些IP
              new_ips=()  # 移除local关键字，因为这不在函数内
              for ((i=0; i<$ROUND; i++)); do
                ip=$(generate_random_ip_from_cidr "$cidr")  # 移除local关键字
                if [ -n "$ip" ]; then
                  new_ips+=($ip)
                fi
              done
              
              # 添加到总列表并去重
              for ip in "${new_ips[@]}"; do
                if [[ ! " ${IPS[*]} " =~ " $ip " ]]; then
                  IPS+=($ip)
                fi
              done
            done
            
            ROUND=$((ROUND + 1))
          done
          
          # 限制IP数量
          IPS=(${IPS[@]:0:$TARGET_COUNT})
          echo "最终生成${#IPS[@]}个不重复IP"
          
          # 步骤3: 测试IP延迟
          echo "开始测试IP延迟 (并发数: $CONCURRENCY, 超时: $TIMEOUT ms)"
          
          # 创建临时文件存储结果
          RESULTS_FILE=$(mktemp)
          
          # 定义测试单个IP的函数
          test_single_ip() {
            local ip=$1
            local port=$2
            local timeout=$3
            local result_file=$4
            
            # 构建测试URL
            local hex_parts=()
            IFS='.' read -r -a ip_parts <<< "$ip"
            for part in "${ip_parts[@]}"; do
              hex_parts+=($(printf '%02x' "$part"))
            done
            local nip=$(echo "${hex_parts[*]}" | tr -d ' ')
            local test_url="https://${nip}.${NIP_DOMAIN}:${port}/cdn-cgi/trace"
            
            # 预请求以缓存DNS解析结果（不计入延迟）
            curl -sS --max-time $((timeout / 1000)) --connect-timeout $((timeout / 1000)) --insecure "$test_url" > /dev/null 2>&1
            
            # 正式测试并测量延迟
            local start_time=$(date +%s%3N)
            local response=$(curl -sS --max-time $((timeout / 1000)) --connect-timeout $((timeout / 1000)) --insecure "$test_url" 2>&1)
            local end_time=$(date +%s%3N)
            local latency=$((end_time - start_time))
            
            # 检查是否超时或失败
            if [[ $latency -ge $timeout ]] || [[ $response == *"curl: ("* ]] || [[ -z $response ]]; then
              echo "IP $ip:$port 测试失败或超时 ($latency ms)" >&2
              return 1
            fi
            
            # 解析响应获取colo信息
            local colo=$(echo "$response" | grep '^colo=' | cut -d'=' -f2)
            local resp_ip=$(echo "$response" | grep '^ip=' | cut -d'=' -f2)
            
            if [ -z "$colo" ] || [ -z "$resp_ip" ]; then
              echo "IP $ip:$port 响应解析失败" >&2
              return 1
            fi
            
            # 判断IP类型
            local ip_type="official"
            if [[ $resp_ip == *":"* ]] || [[ $resp_ip == $ip ]]; then
              ip_type="proxy"
            fi
            
            # 记录结果
            echo "$latency,$ip,$port,$colo,$ip_type" >> "$result_file"
            echo "IP $ip:$port 测试成功: $latency ms, colo: $colo, 类型: $ip_type"
            return 0
          }
          
          # 设置并行运行
          export -f test_single_ip
          export NIP_DOMAIN
          
          # 使用parallel进行并发测试
          echo "${IPS[@]}" | tr ' ' '\n' | parallel -j $CONCURRENCY --progress "test_single_ip {} $PORT $TIMEOUT $RESULTS_FILE"
          
          # 步骤4: 处理结果
          valid_results=$(wc -l < "$RESULTS_FILE")  # 移除local关键字
          echo "测试完成，找到 $valid_results 个有效IP"
          
          if [ $valid_results -eq 0 ]; then
            echo "没有找到有效的IP，程序退出" >&2
            exit 1
          fi
          
          # 按延迟排序并选择最优IP
          echo "前${COUNT}个最优IP："
          best_ips=()  # 移除local关键字
          counter=1    # 移除local关键字
          
          # 排序并提取结果
          sort -n "$RESULTS_FILE" | head -n $COUNT | while IFS=',' read -r latency ip port colo ip_type; do
            type_text="官方优选"  # 这里可以保留local，因为这在while循环内
            if [ "$ip_type" = "proxy" ]; then
              type_text="反代优选"
            fi
            echo "${counter}. ${ip}:${port}#${colo} ${type_text} ${latency}ms"
            best_ips+=("${ip}:${port}")
            counter=$((counter + 1))
          done
          
          # 保存结果到文件
          echo "${best_ips[*]}" | tr ' ' '\n' > "$OUTPUT_FILE"
          echo "已将前${#best_ips[@]}个最优IP保存到文件: $OUTPUT_FILE"
          
          # 输出GitHub Actions友好的结果
          best_ips_csv=$(echo "${best_ips[*]}" | tr ' ' ',')
          echo "::set-output name=best_ips::${best_ips_csv}"
          echo "::set-output name=best_ip::${best_ips[0]}"
          echo "::set-output name=ip_count::${#best_ips[@]}"
          
          echo "程序执行完成"
      
      # 5. 保存结果为Artifact
      - name: 保存IP结果
        uses: actions/upload-artifact@v4
        with:
          name: best-cloudflare-ips
          path: best-ips.txt
          retention-days: 7  # 保留7天
      
      # 6. 更新README或结果文件(可选)
      - name: 更新结果文件
        if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' }}
        run: |
          # 创建或更新结果文件
          RESULT_FILE="CLOUDFLARE_BEST_IPS.md"
          
          echo "# Cloudflare 最优IP列表 ($(date +'%Y-%m-%d %H:%M:%S'))" > $RESULT_FILE
          echo "" >> $RESULT_FILE
          echo "## 配置信息" >> $RESULT_FILE
          echo "- IP来源: CM整理列表 (固定)" >> $RESULT_FILE
          echo "- 测试端口: ${{ github.event.inputs.port || '443' }}" >> $RESULT_FILE
          echo "- 选择数量: ${{ github.event.inputs.count || '16' }}" >> $RESULT_FILE
          echo "- 生成时间: $(date +'%Y-%m-%d %H:%M:%S')" >> $RESULT_FILE
          echo "" >> $RESULT_FILE
          echo "## 最优IP列表" >> $RESULT_FILE
          echo "```" >> $RESULT_FILE
          cat best-ips.txt >> $RESULT_FILE
          echo "```" >> $RESULT_FILE
      
      # 7. 提交结果文件(可选)
      - name: 提交结果更新
        if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' }}
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "Update Cloudflare best IPs"
          file_pattern: CLOUDFLARE_BEST_IPS.md
          commit_user_name: 'GitHub Actions'
          commit_user_email: 'actions@github.com'
          commit_author: 'GitHub Actions <actions@github.com>'

  # 可选：通知作业 - 例如发送邮件或消息通知
  notify-results:
    needs: select-cloudflare-ips
    runs-on: ubuntu-latest
    if: ${{ needs.select-cloudflare-ips.outputs.ip_count > 0 }}
    steps:
      # 这里可以添加通知逻辑，如发送邮件、Slack消息等
      # 示例: 输出结果到日志
      - name: 输出优选结果
        run: |
          echo "找到 ${{ needs.select-cloudflare-ips.outputs.ip_count }} 个最优IP"
          echo "最优IP: ${{ needs.select-cloudflare-ips.outputs.best_ip }}"
          echo "所有优选IP: ${{ needs.select-cloudflare-ips.outputs.best_ips }}"

  # 可选：部署作业 - 例如将结果应用到其他系统
  deploy-ips:
    needs: select-cloudflare-ips
    runs-on: ubuntu-latest
    if: ${{ needs.select-cloudflare-ips.outputs.ip_count > 0 }}
    steps:
      # 这里可以添加部署逻辑，如更新配置文件、通知其他系统等
      # 示例: 创建一个简单的配置文件
      - name: 创建配置文件
        run: |
          echo "# Cloudflare 优选IP配置" > cloudflare-config.txt
          echo "# 生成时间: $(date +'%Y-%m-%d %H:%M:%S')" >> cloudflare-config.txt
          echo "" >> cloudflare-config.txt
          
          # 分割IP列表并添加到配置文件
          IFS=',' read -ra IPS <<< "${{ needs.select-cloudflare-ips.outputs.best_ips }}"
          for ip in "${IPS[@]}"; do
            echo "IP=${ip}" >> cloudflare-config.txt
          done
